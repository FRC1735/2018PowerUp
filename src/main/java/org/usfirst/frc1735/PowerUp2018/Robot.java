// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1735.PowerUp2018;

import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.TimedRobot;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import org.usfirst.frc1735.PowerUp2018.commands.*;
import org.usfirst.frc1735.PowerUp2018.subsystems.*;

import com.kauailabs.navx.frc.AHRS;

import edu.wpi.first.wpilibj.SPI;

import org.usfirst.frc1735.PowerUp2018.Robot;

/**
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the TimedRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the build.properties file in 
 * the project.
 */
public class Robot extends TimedRobot {

    Command autonomousCommand;
    SendableChooser<Command> chooser = new SendableChooser<>();

    // For choosing which side of the field we have placed the robot:
    public static SendableChooser<String> fieldPositionChooser = new SendableChooser<>();
    
    public static OI oi;
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public static DriveTrain driveTrain;
    public static Elevator elevator;
    public static ClampsDeployer clampsDeployer;
    public static Clamps clamps;
    public static PiggybackBar piggybackBar;
    public static Hook hook;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // Additional member variables
    // High-pass filter.  Any joystick absolute value less than this should be clamped to zero.
    public static double m_joystickFilter = 0.08;
    
    // Variables that store (from the FMS GameSpecificMessage) which side of the switch/plate is assigned to our alliance
    public static boolean m_switchIsLeft = false;
    public static boolean m_switchIsRight = false;
    
    public static boolean m_scaleIsLeft = false;
    public static boolean m_scaleIsRight = false;
    
    // Variables that store (from the SmartDashboard) our physical robot placement on the field:
    public static boolean m_robotIsFarRight = false;
    public static boolean m_robotIsMidRight = false;
    public static boolean m_robotIsFarLeft  = false;
    public static boolean m_robotIsMidLeft  = false;

    // NAVX-MXP interface
    public static AHRS ahrs;

    /**
     * This function is run when the robot is first started up and should be
     * used for any initialization code.
     */
    @Override
    public void robotInit() {
        RobotMap.init();
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        driveTrain = new DriveTrain();
        elevator = new Elevator();
        clampsDeployer = new ClampsDeployer();
        clamps = new Clamps();
        piggybackBar = new PiggybackBar();
        hook = new Hook();

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        // OI must be constructed after subsystems. If the OI creates Commands
        //(which it very likely will), subsystems are not guaranteed to be
        // constructed yet. Thus, their requires() statements may grab null
        // pointers. Bad news. Don't move it.
        oi = new OI();

        // Add commands to Autonomous Sendable Chooser
        // We want to override the default behavior that RobotBuilder spits out for the default because it's not controllable.
        // Therefore, we modify the begin/end code so that RobotBuilder does not overwrite this section.
        // Sadly, this also means the checkboxes in RobotBuilder will have no effect...
        // DO NOT BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

        chooser.addDefault("Built In Autonomous", new BuiltInAutonomous()); // This command is a placeholder!!  we compare against it in Robot.autonomousInit() to determine whether to run that function's built-in autonomous choosing code.
        chooser.addObject("Auto Do Nothing", new AutoDoNothing()); // Issues a wait(1) and nothing else.
        chooser.addObject("AutoLineOnly", new AutoLineOnly()); // Cross the auto line and stop.
        chooser.addObject("Autonomous Experiment", new AutonomousExperiment()); // Good for the oddball experiment you want to try
        chooser.addObject("Autonomous Single Command", new AutonomousCommand()); // If you just wanted to add one solitary command, implement it here.

    // DO NOT END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
        SmartDashboard.putData("Auto mode", chooser);
        
        // Set an initial value for SmartDashboard's joystick deadzone variable
    	SmartDashboard.putNumber("Joystick Deadzone", m_joystickFilter);
    	
    	//Competition and practice robots have different followers for the drivetrain.  (practice is talon, competition is victor)
    	SmartDashboard.putBoolean("PracticeBot", false);

    	//Force the robot into Arcade mode on startup (also updates SmartDashboard)
    	Robot.driveTrain.setArcadeMode();
    	
    	//Set an initial value for SquaredInputs (which is used for joystick routines to provide increased sensitivity at low speeds)
    	SmartDashboard.putBoolean("SquaredInputs", true);
    	
    	// Create chooser options for Field placement:
    	fieldPositionChooser.addObject ("Far Left", "Far Left");
    	fieldPositionChooser.addObject ("Mid Left", "Mid Left");
    	fieldPositionChooser.addObject ("Mid Right", "Mid Right");
    	fieldPositionChooser.addDefault("Far Right", "Far Right"); // tag, value (both happen to be the same for this use)
        // Add the chooser widget to the dashboard
        SmartDashboard.putData("Robot Field Position", fieldPositionChooser);
        
        //Value to be used for the SmartDashboard-provided elevator move function.
        SmartDashboard.putNumber("Elev Timeout", 0); // Timeout in seconds
        SmartDashboard.putNumber("Elev magDir", 0); // Magnitude/direction
    	
	    try {
			/***********************************************************************
			 * navX-MXP:
			 * - Communication via RoboRIO MXP (SPI, I2C, TTL UART) and USB.            
			 * - See http://navx-mxp.kauailabs.com/guidance/selecting-an-interface.
			 * 
			 * navX-Micro:
			 * - Communication via I2C (RoboRIO MXP or Onboard) and USB.
			 * - See http://navx-micro.kauailabs.com/guidance/selecting-an-interface.
			 * 
			 * Multiple navX-model devices on a single robot are supported.
			 ************************************************************************/
	        ahrs = new AHRS(SPI.Port.kMXP); 
	    } catch (RuntimeException ex ) {
	        DriverStation.reportError("Error instantiating navX MXP:  " + ex.getMessage(), true);
	    }
    	ahrs.zeroYaw(); // Init the gyro to zero degrees
    	
    	//Run some boot-time drivetrain initializtion (some final init will happen at teleop/autonomous init
    	Robot.driveTrain.drivetrainInit();
    }

    /**
     * This function is called when the disabled button is hit.
     * You can use it to reset subsystems before shutting down.
     */
    @Override
    public void disabledInit(){
    	Robot.driveTrain.m_lateInitHasRun = false; // clear when we disable, so we can change practicebot setting if someone fouled it up the first time.
    }

    @Override
    public void disabledPeriodic() {
        Scheduler.getInstance().run();
    }

    @Override
    public void autonomousInit() {
    	// Some late initialization that happens between robotInit() and actual robot execution
    	Robot.driveTrain.lateInit();
    	// Fetching the autonomous info may take soooo long that the motor safety trips...?
    	// Avoid this by going into PID mode now (Which disables safety check)
    	Robot.driveTrain.setPIDMode();
    	
    	// Clear out all the booleans because they may be stale from a previous run...
    	m_switchIsLeft = false;
    	m_switchIsRight = false;
    	m_scaleIsLeft = false;
    	m_scaleIsRight = false;
    	m_robotIsFarLeft = false;
    	m_robotIsMidLeft = false;
    	m_robotIsMidRight = false;
    	m_robotIsFarRight = false;
    
    	// Ask the AutonomousChooser for guidance.
    	// if it says to run the hard-coded routine, do that.
    	// Otherwise, if we override that, do what it says to do.
    	// Clear out our autonomousCommand:
    	autonomousCommand = null;
    	
    	// Get the chooser value
    	if (chooser.getSelected().getName().equals("BuiltInAutonomous"))
    	{
    		System.out.println("SD says we should run the hard-coded Autonomous Command choice...");

    		// Get the Game Specific String and parse it into variables
    		String gameData;
    		gameData = DriverStation.getInstance().getGameSpecificMessage();
    		if(gameData.length() > 0) {
    			// Print it to the DS log (it's not REALLY an error, but this gets it permanently logged for future debug)
    			DriverStation.reportWarning("(Info) GameSpecificString for match " + DriverStation.getInstance().getMatchNumber() + ": " + gameData, false);

    			// Get the Switch assignment
    			if(gameData.charAt(0) == 'L') {
    				m_switchIsLeft = true;
    			}
    			else {
    				m_switchIsRight = true;
    			}
    			// Get the Scale assignment
    			if(gameData.charAt(1) == 'L') {
    				m_scaleIsLeft = true;
    			}
    			else {
    				m_scaleIsRight = true;
    			}
    		}
    		else {
    			// We should ALWAYS get a string during AutonomousInit!!!  If we get here, something went really really wrong...
    			DriverStation.reportError("Received zero length game data at autonomousInit!! ", false);
    		}

    		// Get our physical placement on the field from the SmartDashboard
    		DriverStation.reportWarning("(Info) Robot Field Position is " + Robot.fieldPositionChooser.getSelected(), false);
    		switch (Robot.fieldPositionChooser.getSelected()) {
    		case "Far Right":
    			m_robotIsFarRight = true;
    			break;
    		case "Mid Right":
    			m_robotIsMidRight = true;
    			break;
    		case "Far Left":
    			m_robotIsFarLeft = true;
    			break;
    		case "Mid Left":
    			m_robotIsMidLeft = true;
    			break;
    		default:
    			// Uh, oh...  Nothing came back that matched!  Print a REAL error:
    			DriverStation.reportError("Received invalid field position from SmartDashboard: " + Robot.fieldPositionChooser.getSelected(), false);
    			break;
    		}

    		// Create some derived information from these two pieces of data
    		boolean isOurSwitch = (
    				(m_robotIsFarRight && m_switchIsRight) ||
    				(m_robotIsFarLeft && m_switchIsLeft) ||
    				(m_robotIsMidRight && m_switchIsRight) ||
    				(m_robotIsMidLeft && m_switchIsLeft));
    		boolean isOurScale = (
    				(m_robotIsFarRight && m_scaleIsRight) ||
    				(m_robotIsFarLeft && m_scaleIsLeft) ||
    				(m_robotIsMidRight && m_scaleIsRight) ||
    				(m_robotIsMidLeft && m_scaleIsLeft));

    		DriverStation.reportWarning("(Info) isOurSwitch=" + isOurSwitch + "; isOurScale=" + isOurScale, false);;

    		// Now, what do we DO with this information??
    		// we choose our Autonomous based on three criteria:
    		// 1) are we in a far L/R corner, or in a mid L/R position?
    		// 2) Based on our L/R placement, is the switch on our side?
    		// 3) Based on our L/R placement, is the scale on our side?
    		// Based on those critera, we then choose one of the available autonomous commands and run it.
    		// Left/right inversion is done inside the commands via a ConditionalTurn object that is smart enough to know whether to mirror or not.
    		//
    		//There are many ways this could be implemented, but in order to explicitly catch any "fall throughs" we'll code each condition explicitly rather than as a series of if/else.
    		if 		((m_robotIsMidRight || m_robotIsMidLeft) && // midfield robot placement of robot and
    				( isOurSwitch))                            // it's our switch
    		{
    			autonomousCommand = new AutoSwitch1x(); //We are midfield; deliver our cube straight to the switch in front of us.
    		}

    		else if((m_robotIsMidRight || m_robotIsMidLeft) && // midfield placement of robot but
    				(!isOurSwitch))                            // it's NOT our switch
    		{
    			autonomousCommand = new AutoLineOnly(); // We are midfield, but must not deliver our cube.  Just cross the auto line for points.
    		}

    		else if((m_robotIsFarRight || m_robotIsFarLeft) && // Corner placement of robot and
    				( isOurSwitch)  &&                         // it's our switch and
    				( isOurScale))                             // it's our scale
    		{
    			//autonomousCommand = new AutoSwitchAndScale(); // We have both switch and scale on our side!  Deliver to both.
    			// With half a lift, we can't do the scale, so do two switches
    			autonomousCommand = new AutoSwitch2x();
    		}
    		else if((m_robotIsFarRight || m_robotIsFarLeft) && // Corner placement of robot and
    				( isOurSwitch)  &&                         // it's our switch but
    				(!isOurScale))                             // it's NOT our scale
    		{
    			autonomousCommand = new AutoSwitch2x(); // We have switch but not scale.  Deliver two cubes to the switch
    		}
    		else if((m_robotIsFarRight || m_robotIsFarLeft) && // Corner placement of robot and
    				(!isOurSwitch)  &&                         // it's NOT our switch but
    				( isOurScale))                             // it's our scale
    		{
    			//autonomousCommand = new AutoScale2x(); // We have scale but not switch.  Deliver two cubes to the scale
    			// With half a lift, we can't do the scale.  Since we also don't have the switch, just cross the auto line for points
    			autonomousCommand = new AutoLineOnly(); // We have neither switch nor scale.  Just cross the auto line for points.
    		}
    		else if((m_robotIsFarRight || m_robotIsFarLeft) && // Corner placement of robot but
    				(!isOurSwitch)  &&                         // it's NOT our switch and
    				(!isOurScale))                             // it's NOT our scale
    		{
    			autonomousCommand = new AutoLineOnly(); // We have neither switch nor scale.  Just cross the auto line for points.
    		}
    		else {
    			// We didn't match something somewhere... can't figure out which auto to run.  Punt by just driving to the Auto Line for lack of a better idea
    			DriverStation.reportError("Couldn't find a valid auto command to run!  Defaulting to AutoLineOnly", false);
    			DriverStation.reportError("Field:FL.ML.MR.FR= "+ m_robotIsFarLeft + m_robotIsMidLeft + m_robotIsMidRight + m_robotIsFarRight + ", isOurSwitch= " + isOurSwitch + "isOurScale= " + isOurScale, false);
    			autonomousCommand = new AutoLineOnly();
    		}
    	}
    	else // override the built-in choice above...
    	{
    		DriverStation.reportWarning("SD says we should run an override autonomous: " + chooser.getSelected().getName(), false);
    		autonomousCommand = chooser.getSelected();
    	}

    	//System.out.println("println:  AutonomousCommand chosen: " + autonomousCommand.getName());
    	DriverStation.reportWarning("(Info) AutonomousCommand chosen: " + autonomousCommand.getName(), false);
    	// Finally, we can run the chosen Autonomous mode...
    	if (autonomousCommand != null) {
    		autonomousCommand.start();
    	}
    	else {
    		DriverStation.reportError("AutonomousInit calculated a null Autonomous!!!!", false);
    	}

    }

    /**
     * This function is called periodically during autonomous
     */
    @Override
    public void autonomousPeriodic() {
        Scheduler.getInstance().run();
    }

    @Override
    public void teleopInit() {
        // This makes sure that the autonomous stops running when
        // teleop starts running. If you want the autonomous to
        // continue until interrupted by another command, remove
        // this line or comment it out.
        if (autonomousCommand != null) autonomousCommand.cancel();
        
    	// Some late initialization that happens between robotInit() and actual robot enable
    	Robot.driveTrain.lateInit();
    	//Robot.oi.setJoystickButtonMap(); // Map all joystick buttons based on the joystick types available at this time


    }

    /**
     * This function is called periodically during operator control
     */
    @Override
    public void teleopPeriodic() {
        Scheduler.getInstance().run();
    }
}
