// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1735.PowerUp2018.subsystems;

import org.usfirst.frc1735.PowerUp2018.RobotMap;
import org.usfirst.frc1735.PowerUp2018.commands.*;

import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.NeutralMode;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class Elevator extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final WPI_TalonSRX elevatorMotor = RobotMap.elevatorElevatorMotor;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new ElevatorWithJoystick());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop
    }
    
    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    
    public void initializeElevator() {
    	// This function puts the elevator in Motion Magic control mode.
    	// this allows us to use the Talon HW PID for positional control,
    	// while still obeying the trapezoidal motion profile for acceleration
    	// and maximum velocity.
    	
    	// See full code example at https://github.com/CrossTheRoadElec/FRC-Examples-STEAMWORKS/blob/master/JAVA_MotionMagicExample/src/org/usfirst/frc/team217/robot/Robot.java
    	    	
		/* set the peak and nominal outputs, -1 to 1 in percentage of nominal voltage (even if battery voltage is higher)*/
    	elevatorMotor.configNominalOutputForward(0.0, 0);
    	elevatorMotor.configNominalOutputReverse(-0.0, 0);
    	elevatorMotor.configPeakOutputForward(kPIDOutputMax,0);
    	elevatorMotor.configPeakOutputReverse(-kPIDOutputMax,0);
    	    
    	/* set closed loop gains in slot0 - see documentation */
    	elevatorMotor.selectProfileSlot(0,0);
    	
		/* set acceleration and vcruise velocity - see documentation */
    	elevatorMotor.configMotionCruiseVelocity(27, 0); // 27 encoder units per 100ms interval is about 160 RPM
    	
    	elevatorMotor.configMotionAcceleration(270, 0); //want to get to full speed in 1/10 sec

    	// Set the closed loop ramp as well (time in seconds to full speed; timeout)
    	elevatorMotor.configClosedloopRamp(0.1, 0); //want to get to full speed in 1/10 sec
    	elevatorMotor.configOpenloopRamp(0.1, 0); //want to get to full speed in 1/10 sec
    	
    	// Put the talons in "Brake" mode for a little more accuracy
    	elevatorMotor.setNeutralMode(NeutralMode.Brake);
   	     	    	
    	//Initially set the mode to open-loop PID.  Second arg is the setpoint of zero to turn the motor off.
        elevatorMotor.set(ControlMode.PercentOutput, 0);
        
        //Set the closed-loop allowable error.  Empirically on no-load, error was <50 units.
        elevatorMotor.configAllowableClosedloopError(0, kToleranceDistUnits, 0); // index, err, timeout in ms
    }
    
    public void elevateWithJoystick(Joystick joy) {
		// Extract the joystick values
		double joyY; // Y axis value of the joystick

		// If an Xbox controller, we have to specify which "hand" joystick to get.		
		if (DriverStation.getInstance().getJoystickIsXbox(joy.getPort())) {// if Xbox controller
			joyY = joy.getRawAxis(5);  // right-hand joystick Y
		}
		else {
			joyY  = joy.getY();
		}

		// Apply the 'dead zone' guardband to the joystick inputs:
		// Centered joysticks may not actually read as zero due to spring variances.
		// Therfore, remove any small values as being "noise".
		double joystickDeadzone = SmartDashboard.getNumber("Joystick Deadzone", 0); // default to zero if entry not found
		if (Math.abs(joyY) < joystickDeadzone)
			joyY = 0;

		// Choose whether we square the inputs (for increased joystick sensitivity at low speeds) based on SmartDashboard settings.
    	boolean squaredInputs = SmartDashboard.getBoolean("SquaredInputs", true); // Default to true if setting not found
    	if (squaredInputs) {
    		if (joyY < 0) {
    			joyY = -(joyY * joyY);
    		}
    		else if (joyY > 0){
    		 joyY =(joyY * joyY);
    		}
    	}

    	// Drive the elevator motor with the joystick value
    	//elevatorMotor.set(ControlMode.PercentOutput, -joyY); //Positive motor values should move the elevator up.  Joystick "up" is a negative number, so invert.
    }
    
    // Member Variables
    public static final int kToleranceDistUnits = 3; // stop if we are within this many encoder units of our setpoint. 1023 units across ~84in, so if we want 0.25" accuracy that's 3 ticks.

    static final double kP = 0.0165;
    static final double kI = 0.0;
    static final double kD = 0.0;
    static final double kF = 0.0;
    public static final double kPIDOutputMax = 1.0; // Max motor output in PID mode

}
