// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1735.PowerUp2018.commands;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import java.util.List;

import org.usfirst.frc1735.PowerUp2018.Robot;
import org.usfirst.frc1735.PowerUp2018.RobotMap;
import org.usfirst.frc1735.PowerUp2018.subsystems.Elevator;

import com.ctre.phoenix.motorcontrol.ControlMode;

/**
 *
 */
public class ElevatorwithPID extends Command {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
    private double m_height;
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public ElevatorwithPID(double height) {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        m_height = height;

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.elevator);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }
    
    //Void constructor gets height from SmartDashboard.  Allows us to use a button (w/ no preset) to call the command
    public ElevatorwithPID() {
    	m_getHeightFromSmartDashboard = true;

    	requires(Robot.elevator);
    }
    
    // Called just before this Command runs the first time
    @Override
    protected void initialize() {
    	double p = SmartDashboard.getNumber("ElevP", 0);
    	double i = SmartDashboard.getNumber("ElevI", 0);
    	double d = SmartDashboard.getNumber("ElevD", 0);
    	double f = SmartDashboard.getNumber("ElevF", 0.3789);
    	RobotMap.elevatorElevatorMotor.config_kP(0, p, 0); // Slot, value, timeout in ms
    	RobotMap.elevatorElevatorMotor.config_kI(0, i, 0); // Slot, value, timeout in ms
    	RobotMap.elevatorElevatorMotor.config_kD(0, d, 0); // Slot, value, timeout in ms
    	RobotMap.elevatorElevatorMotor.config_kF(0, f, 0); // Slot, value, timeout in ms

    	// Initialize the desired max speed and acceleration:
    	m_magDir = (int) SmartDashboard.getNumber("Cruise SpeedDir", 2700); // default to full speed
    	RobotMap.elevatorElevatorMotor.configMotionCruiseVelocity(m_magDir, 0);  // speed in encoder units per 100ms
    	
    	m_accel = (int) SmartDashboard.getNumber("Elev Accel", 8100); //full speed in 1/3 sec
    	RobotMap.elevatorElevatorMotor.configMotionAcceleration(m_accel, 0); //want xPM in 1 sec, so x/60/10*4096 = 3072 units/100ms

    	// If we created this command without args, it should get its height from the SmartDashboard:
    	// (if not, it was already passed in from the parent CommandGroup and set in the constructor)
    	if (m_getHeightFromSmartDashboard) {     	
    		m_height = SmartDashboard.getNumber("Height", 10);
    		System.out.println("Initializing elevator height from SmartDashboard");
    	}

     	//Set a timeout value in seconds
    	setTimeout(1.5);
    	    	    	
    	// Calculate the "encoder height".  our command input is in something human-readable:  Inches.
    	// But the HW PID controller wants height in encoder units.
    	m_encHeight = (int)(m_height * Elevator.kEncoderTicksPerInch);
    	    	
    	System.out.println("ElevatorWithPID has been reqeusted for " + m_height + " inches, or " + m_encHeight + " encoder ticks");

    }

    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute() {
    	// Just update the motor setpoints
    	RobotMap.elevatorElevatorMotor.set(ControlMode.Position/*MotionMagic*/, m_encHeight);
    }

    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished() {
    	//  update our rolling average height traveled.  We need to compare this AVERAGE when deciding when to terminate.
    	double avgHeight = calcAvgHeight(RobotMap.elevatorElevatorMotor.getSelectedSensorPosition(0));

    	System.out.println(" FLerr: " + RobotMap.elevatorElevatorMotor.getClosedLoopError(0) +
    			" out_pct: " + RobotMap.elevatorElevatorMotor.getMotorOutputPercent() +
    			" CLTarget: " + RobotMap.elevatorElevatorMotor.getClosedLoopTarget(0) +
    			" Pos: " + RobotMap.elevatorElevatorMotor.getSelectedSensorPosition(0) +
    			" Vel: " + RobotMap.elevatorElevatorMotor.getSelectedSensorVelocity(0) + 
    			" Mode: " + RobotMap.elevatorElevatorMotor.getControlMode() + 
    			" AvgHeight: " + avgHeight);
  				
    	//@FIXME:  Should finished be checking BOTH sensors??
    	
    	// The most intuitive thing to check would be the closed loop error, and if it's less than the allowable error we're done.
    	// However, the first ~5 iterations (@20ms, this is about 100ms) don't report accurate CLerr, so we'll avoid that and instead check if our sensor position is within the allowed error of the setpoint.
    	// Unfortunately, the first iteration of the command hasn't yet actually seen the zeroed out sensor and will see whatever position was present prior to starting this command.
    	// So, we need to skip checking anything on the first iteration.
    	boolean heightReached = (Math.abs(avgHeight - m_encHeight) < Elevator.kToleranceHeightUnits);
    	
    	if (m_loopCount > 1) //The first execute will inc to 1, so the first isFinished will see 1 as well.  this is the iteration we want to skip.
    		return heightReached || isTimedOut();
    	else
    		return false; // On the first iteration, don't terminate (we have no valid data upon which to calculate a termination value!)
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
    	// Do nothing; leave the PID loop running so that the cube stays in the same place while we drive around.
    	
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
    	end();
    }
    
    // Given a new height, calculate a new rolling average.
    protected double calcAvgHeight(int latestHeight) {
    	// Remove the oldest item in the heightHistory (if too many exist)
    	while (m_heightHistory.size() > 1000) // Rolling average of five items 0..4
    		m_heightHistory.remove(0);
    	
    	// Add the latest height to the list
    	m_heightHistory.add(latestHeight);
    	
    	// Calculate the new average
    	double newSum =  0;
    	for (int i=0; i< m_heightHistory.size(); i++) {
    		newSum = newSum + m_heightHistory.get(i);
    	}

    	double newAvg = newSum / m_heightHistory.size();
    	return newAvg;
    }
     
    // Member Variables
    boolean m_getHeightFromSmartDashboard = false;
    int m_magDir;
    int m_accel;
    double m_loopCount;
    double m_encHeight; // This is the requested height in encoder ticks, as opposed to m_height which is in inches.
    private List<Integer> m_heightHistory;  // Holds a history of previous sensor height values
}
	
