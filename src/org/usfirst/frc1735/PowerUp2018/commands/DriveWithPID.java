// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1735.PowerUp2018.commands;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import org.usfirst.frc1735.PowerUp2018.Robot;
import org.usfirst.frc1735.PowerUp2018.RobotMap;
import org.usfirst.frc1735.PowerUp2018.subsystems.DriveTrain;

import com.ctre.phoenix.motorcontrol.ControlMode;

/**
 *
 */
public class DriveWithPID extends Command {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
    private double m_distance;
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public DriveWithPID(double distance) {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        m_distance = distance;

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.driveTrain);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        
    }

    //Void constructor gets distance from SmartDashboard
    public DriveWithPID() {
    	System.out.println("DriveWithPID Null constructor called");
    	m_getDistFromSmartDashboard = true;
        requires(Robot.driveTrain);
    }

    // Called just before this Command runs the first time
    @Override
    protected void initialize() {
    	//Set the driveline's Talons into MotionMagic mode
    	Robot.driveTrain.motionMagicInit();
    	//PID for this command
    	double p = SmartDashboard.getNumber("P", 1);
    	double i = SmartDashboard.getNumber("I", 0);
    	double d = SmartDashboard.getNumber("D", 0);
    	double f = SmartDashboard.getNumber("F", 0.3789);
    	RobotMap.driveTrainLeftMotor.config_kP(0, p, 0); // Slot, value, timeout in ms
    	RobotMap.driveTrainLeftMotor.config_kI(0, i, 0); // Slot, value, timeout in ms
    	RobotMap.driveTrainLeftMotor.config_kD(0, d, 0); // Slot, value, timeout in ms
    	RobotMap.driveTrainLeftMotor.config_kF(0, f, 0); // Slot, value, timeout in ms
    	//RobotMap.driveTrainRightMotor.config_kP(0, p, 0); // Slot, value, timeout in ms
    	//RobotMap.driveTrainRightMotor.config_kI(0, i, 0); // Slot, value, timeout in ms
    	//RobotMap.driveTrainRightMotor.config_kD(0, d, 0); // Slot, value, timeout in ms
    	//RobotMap.driveTrainRightMotor.config_kF(0, f, 0); // Slot, value, timeout in ms
    	//RobotMap.driveTrainLeftFollower.config_kP(0, p, 0); // Slot, value, timeout in ms
    	//RobotMap.driveTrainLeftFollower.config_kI(0, i, 0); // Slot, value, timeout in ms
    	//RobotMap.driveTrainLeftFollower.config_kD(0, d, 0); // Slot, value, timeout in ms
    	//RobotMap.driveTrainLeftFollower.config_kF(0, f, 0); // Slot, value, timeout in ms
    	//RobotMap.driveTrainRightFollower.config_kP(0, p, 0); // Slot, value, timeout in ms
    	//RobotMap.driveTrainRightFollower.config_kI(0, i, 0); // Slot, value, timeout in ms
    	//RobotMap.driveTrainRightFollower.config_kD(0, d, 0); // Slot, value, timeout in ms
    	//RobotMap.driveTrainRightFollower.config_kF(0, f, 0); // Slot, value, timeout in ms
    	
    	// If we created this command without args, it should get its distance from the SmartDashboard:
    	if (m_getDistFromSmartDashboard) { 
    		System.out.println("Initializing drive distance from SmartDashboard");
    		m_distance = (int) SmartDashboard.getNumber("Cruise Dist", 4096); // one revolution default
    	}

    	//Set a timeout
    	setTimeout(3);
    }

    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute() {
    	m_magDir = (int) SmartDashboard.getNumber("Cruise SpeedDir", 2700); // default to full speed
    	RobotMap.driveTrainLeftMotor.configMotionCruiseVelocity(m_magDir, 0);  // want X rpm (X \ 60s/min /10 100ms/sec *4096 units/Rev = 3072 units/100ms)
    	//RobotMap.driveTrainRightMotor.configMotionCruiseVelocity(Math.toIntExact(Math.round(m_magDir /60 /10 *4096)), 0);
    	//RobotMap.driveTrainLeftFollower.configMotionCruiseVelocity(Math.toIntExact(Math.round(m_magDir /60 /10 *4096)), 0);
    	//RobotMap.driveTrainRightFollower.configMotionCruiseVelocity(Math.toIntExact(Math.round(m_magDir /60 /10 *4096)), 0);
    	
    	m_accel = (int) SmartDashboard.getNumber("Cruise Accel", 8100); //full speed in 1/3 sec
    	RobotMap.driveTrainLeftMotor.configMotionAcceleration(m_accel, 0); //want xPM in 1 sec, so x/60/10*4096 = 3072 units/100ms
    	//RobotMap.driveTrainRightMotor.configMotionAcceleration(Math.toIntExact(Math.round(m_accel /60 /10 *4096)), 0);
    	//RobotMap.driveTrainLeftFollower.configMotionAcceleration(Math.toIntExact(Math.round(m_accel /60 /10 *4096)), 0);
    	//RobotMap.driveTrainRightFollower.configMotionAcceleration(Math.toIntExact(Math.round(m_accel /60 /10 *4096)), 0);
    	
    	RobotMap.driveTrainLeftMotor.set(ControlMode.MotionMagic, m_distance);
    	RobotMap.driveTrainRightMotor.follow(RobotMap.driveTrainLeftMotor); //Broken sensor :'-(
    	RobotMap.driveTrainLeftFollower.follow(RobotMap.driveTrainLeftMotor);
    	RobotMap.driveTrainRightFollower.follow(RobotMap.driveTrainLeftMotor);
   }

    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished() {
    	System.out.println(" FLerr: " + RobotMap.driveTrainLeftMotor.getClosedLoopError(0) +
    						" out_pct: " + RobotMap.driveTrainLeftMotor.getMotorOutputPercent() +
    						" CLTarget: " + RobotMap.driveTrainLeftMotor.getClosedLoopTarget(0) +
    						" Pos: " + RobotMap.driveTrainLeftMotor.getSelectedSensorPosition(0) +
    						" Vel: " + RobotMap.driveTrainLeftMotor.getSelectedSensorVelocity(0));
    						
    	//					" FRErr: " + RobotMap.driveTrainRightMotor.getClosedLoopError(0));
    	//@FIXME:  Should finished be checking BOTH sensors??
    	boolean distReached = (Math.abs(RobotMap.driveTrainLeftMotor.getSelectedSensorPosition(0) - m_distance) < DriveTrain.kToleranceDistUnits);
        return isTimedOut(); //distReached; // Eventually OR in isTimedOut();
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
    	RobotMap.driveTrainLeftMotor.set(0);
    	RobotMap.driveTrainRightMotor.set(0);
    	RobotMap.driveTrainLeftFollower.set(0);
    	RobotMap.driveTrainRightFollower.set(0);
    	Robot.driveTrain.setDriveMode();
    	
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
    	end();
    }
    //Member Variables
    int m_magDir;
    int m_accel;
    boolean m_getDistFromSmartDashboard = false;
}
